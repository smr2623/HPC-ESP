 MODULE FPSM2D_PINPUT
!purpose: manage the input for the fpsm2d with MPI
!usage: initialize the object with CALL FPSM2D_PINPUT_NEW(INPUT,P,OK)
!       where
!       INPUT is of type FPSM2D_PINPUT_TYPE  
!       and OK is logical
! 
 
  USE FPSM2D_PARALLELISM
  USE FPSM2D_GENINPUT
  USE FPSM2D_DDATA

  IMPLICIT NONE
  
  TYPE FPSM2D_PINPUT_TYPE
   PRIVATE
     TYPE(FPSM2D_GENINPUT_TYPE) :: GENINPUT !same for all processes
     REAL, DIMENSION(:,:,:), POINTER :: DDATA !different for each process
	 INTEGER :: NDX,NDY
  END TYPE FPSM2D_PINPUT_TYPE
 
 
 CONTAINS
 !=======================================
 
  SUBROUTINE FPSM2D_PINPUT_NEW(THIS,OK)
   TYPE(FPSM2D_PINPUT_TYPE), INTENT(INOUT) :: THIS
   LOGICAL, INTENT(OUT) :: OK
   !-----------------------------------------
   LOGICAL :: LROOT
   INTEGER :: IERR,ME,NPES,NX,NY,NEWTYPE,NSIZE,IC
   REAL, DIMENSION(:,:), ALLOCATABLE :: WHOLE
   
   !LROOT  
   CALL MPI_COMM_RANK(MPI_COMM_WORLD,ME,IERR) 
   LROOT=ME.EQ.0
   
   CALL MPI_COMM_SIZE(MPI_COMM_WORLD,NPES,IERR)
   if(LROOT) print*, 'running on ',NPES,'cores'
   
   !only the root process access to files and read general input data
   IF(LROOT) CALL FPSM2D_GENINPUT_LOAD(THIS%GENINPUT,OK)
   !broadcast the information that reading went well
   CALL MPI_BCAST(OK,1,MPI_LOGICAL,0,MPI_COMM_WORLD,IERR)  

   IF(OK) THEN
   
     NEWTYPE=GENINPUT_MPI_TYPE() !FUNCTION DEFINED IN THIS MODULE (SEE BELOW) 
     CALL MPI_TYPE_COMMIT(NEWTYPE,IERR)
     CALL MPI_BCAST(THIS%GENINPUT,1,NEWTYPE,0,MPI_COMM_WORLD,IERR)
     !NOW ALL PROCESSES HAVE GENINPUT DEFINED
     
     print*, 'Pe #',ME, 'geninput bcasted'

     CALL FPSM2D_GENINPUT_GETNXNY(THIS%GENINPUT,NX,NY)
	 THIS%NDX=NX/NPES
	 THIS%NDY=NY/NPES
	 ALLOCATE(THIS%DDATA(NX,THIS%NDY,FPSM2D_DDATA_N))

	 IF(LROOT) THEN
	  ALLOCATE(WHOLE(NX,NY))
	 ELSE 
	  ! WE DO THIS ONLY TO BE ABLE TO PASS AROUND THE ARRAY WHOLE
	  ALLOCATE(WHOLE(1,1)) 
	 ENDIF
	 
	 NSIZE=NX*THIS%NDY
	 DO IC=1,FPSM2D_DDATA_N
	  IF(LROOT) CALL FPSM2D_DDATA_LOAD(WHOLE,IC,OK)
	  !if ok for root then ok for all
      CALL MPI_BCAST(OK,1,MPI_LOGICAL,0,MPI_COMM_WORLD,IERR)    
	  IF(OK) THEN
	    CALL MPI_SCATTER(WHOLE,NSIZE,MPI_REAL,THIS%DDATA(:,:,IC),NSIZE,MPI_REAL,0,MPI_COMM_WORLD,IERR)
	   ELSE
	    EXIT
	  ENDIF
	 ENDDO
    ENDIF
   
   IF(.NOT.OK) PRINT*, 'ERROR IN FPSM2D_PINPUT_NEW' 
  
  END SUBROUTINE FPSM2D_PINPUT_NEW
 !=======================================
 
  SUBROUTINE FPSM2D_PINPUT_KILL(THIS)
   TYPE(FPSM2D_PINPUT_TYPE), INTENT(INOUT) :: THIS
   
     DEALLOCATE(THIS%DDATA)
	 
  END SUBROUTINE FPSM2D_PINPUT_KILL
!======================================= 
 
 INTEGER FUNCTION GENINPUT_MPI_TYPE()
   !-----------------------------------------
   INTEGER :: NEWTYPE,IERR,IEXTENT
   INTEGER(KIND=MPI_ADDRESS_KIND), DIMENSION(2) :: OFFSETS
   INTEGER, DIMENSION(2) :: LENGTHS,ITYPES
   
   !THIS%GENINPUT is structured type 
   ! build of a integer array with length fpsm2d_geninput_nintegers
   ! and a real array with length fpsm2d_geninput_nintegers
   !first  define mpi structured type and commit it to mpi
	 CALL MPI_TYPE_EXTENT(MPI_INTEGER,IEXTENT,IERR)
	 OFFSETS=(/0,IEXTENT*FPSM2D_GENINPUT_NINTEGERS/)
	 LENGTHS=(/FPSM2D_GENINPUT_NINTEGERS,FPSM2D_GENINPUT_NREALS/)
	 ITYPES=(/MPI_INTEGER,MPI_REAL/)
     CALL MPI_TYPE_CREATE_STRUCT(2,LENGTHS,OFFSETS,ITYPES,NEWTYPE,IERR)
	 
    GENINPUT_MPI_TYPE=NEWTYPE
  
  END FUNCTION GENINPUT_MPI_TYPE
 !=======================================
 
  SUBROUTINE FPSM2D_PINPUT_GETMODEL(THIS,MODEL)

   TYPE(FPSM2D_PINPUT_TYPE), INTENT(IN) :: THIS
   REAL, DIMENSION(:,:,:), INTENT(OUT) :: MODEL
   INTEGER :: IC
  
   DO IC=1,3 !FROM FPSM2D_DDATA_VP TO FPSM2D_DDATA_RHO
    MODEL(:,:,IC)=THIS%DDATA(:,:,IC)
   ENDDO
   
  END SUBROUTINE FPSM2D_PINPUT_GETMODEL
 !=======================================
 
  SUBROUTINE FPSM2D_PINPUT_GETSPACE(THIS,N,ND)
  !GIVE DATA ABOUT SPATIAL PARAMETRIZATION
   TYPE(FPSM2D_PINPUT_TYPE), INTENT(IN) :: THIS
   INTEGER, DIMENSION(2), INTENT(OUT) :: N,ND
   
   CALL FPSM2D_GENINPUT_GETNXNY(THIS%GENINPUT,N(1),N(2))
   ND=(/THIS%NDX,THIS%NDY/)
  
  END SUBROUTINE FPSM2D_PINPUT_GETSPACE
 !======================================= 
 
  SUBROUTINE FPSM2D_PINPUT_GETINITIAL(THIS,UOLD,UNOW)
   TYPE(FPSM2D_PINPUT_TYPE), INTENT(IN) :: THIS
   REAL, DIMENSION(:,:,:), INTENT(OUT) :: UOLD,UNOW
   !-------------------------------------------
   INTEGER :: IC
   
    DO IC=1,2
	 UOLD(:,:,IC)=THIS%DDATA(:,:,FPSM2D_DDATA_OLD-1+IC)
	ENDDO
    DO IC=1,2
	 UNOW(:,:,IC)=THIS%DDATA(:,:,FPSM2D_DDATA_NOW-1+IC)
	ENDDO  
  
  END SUBROUTINE FPSM2D_PINPUT_GETINITIAL
 !=======================================
 
 SUBROUTINE FPSM2D_PINPUT_GETNT(THIS,NT,NTRES)
 !WRAPPER TO GENINPUT GETTER
  TYPE(FPSM2D_PINPUT_TYPE), INTENT(IN) :: THIS
  INTEGER, INTENT(OUT) :: NT,NTRES
  
  CALL FPSM2D_GENINPUT_GETNT(THIS%GENINPUT,NT,NTRES)
 
 END SUBROUTINE FPSM2D_PINPUT_GETNT
 !=======================================
 
  SUBROUTINE FPSM2D_PINPUT_GETDDD(THIS,DD,DT)
   TYPE(FPSM2D_PINPUT_TYPE), INTENT(IN) :: THIS
   REAL, DIMENSION(2), INTENT(OUT) :: DD
   REAL, INTENT(OUT) :: DT
   !-------------------------------
   REAL, DIMENSION(3) :: DDD
   
   CALL FPSM2D_GENINPUT_GETDDD(THIS%GENINPUT,DDD)
   
   DD=DDD(1:2)
   DT=DDD(3)
  
  END SUBROUTINE FPSM2D_PINPUT_GETDDD
 !=======================================
 END MODULE FPSM2D_PINPUT